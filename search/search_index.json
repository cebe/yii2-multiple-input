{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Yii2 Multiple input widget. Yii2 widget for handle multiple inputs for an attribute of model and tabular input for batch of models. Latest release The latest stable version of the extension is v2.25.0 Follow the instruction for upgrading from previous versions","title":"About"},{"location":"#yii2-multiple-input-widget","text":"Yii2 widget for handle multiple inputs for an attribute of model and tabular input for batch of models.","title":"Yii2 Multiple input widget."},{"location":"#latest-release","text":"The latest stable version of the extension is v2.25.0 Follow the instruction for upgrading from previous versions","title":"Latest release"},{"location":"clonning/","text":"Clonning use unclead\\multipleinput\\MultipleInput; ... $form->field($model, 'products')->widget(MultipleInput::className(), [ 'max' => 10, 'cloneButton' => true, 'columns' => [ [ 'name' => 'product_id', 'type' => 'dropDownList', 'title' => 'Special Products', 'defaultValue' => 1, 'items' => [ 1 => 'id: 1, price: $19.99, title: product1', 2 => 'id: 2, price: $29.99, title: product2', 3 => 'id: 3, price: $39.99, title: product3', 4 => 'id: 4, price: $49.99, title: product4', 5 => 'id: 5, price: $59.99, title: product5', ], ], [ 'name' => 'time', 'type' => DateTimePicker::className(), 'title' => 'due date', 'defaultValue' => date('d-m-Y h:i') ], [ 'name' => 'count', 'title' => 'Count', 'defaultValue' => 1, 'enableError' => true, 'options' => [ 'type' => 'number', 'class' => 'input-priority', ] ] ] ])->label(false);","title":"Clonning"},{"location":"clonning/#clonning","text":"use unclead\\multipleinput\\MultipleInput; ... $form->field($model, 'products')->widget(MultipleInput::className(), [ 'max' => 10, 'cloneButton' => true, 'columns' => [ [ 'name' => 'product_id', 'type' => 'dropDownList', 'title' => 'Special Products', 'defaultValue' => 1, 'items' => [ 1 => 'id: 1, price: $19.99, title: product1', 2 => 'id: 2, price: $29.99, title: product2', 3 => 'id: 3, price: $39.99, title: product3', 4 => 'id: 4, price: $49.99, title: product4', 5 => 'id: 5, price: $59.99, title: product5', ], ], [ 'name' => 'time', 'type' => DateTimePicker::className(), 'title' => 'due date', 'defaultValue' => date('d-m-Y h:i') ], [ 'name' => 'count', 'title' => 'Count', 'defaultValue' => 1, 'enableError' => true, 'options' => [ 'type' => 'number', 'class' => 'input-priority', ] ] ] ])->label(false);","title":"Clonning"},{"location":"configuration/","text":"Configuration Widget support the following options that are additionally recognized over and above the configuration options in the InputWidget. Base options theme string : specify the theme of the widget. Available 2 themes: default with only widget css classes bs (twitter bootstrap) theme with additional BS ccs classes). Default value is bs max integer : maximum number of rows. If not set will default to unlimited min integer : minimum number of rows. Set to 0 if you need the empty list in case you don't have any data prepend boolean : add a new row to the beginning of the list, not to the end attributeOptions array : client-side attribute options, e.g. enableAjaxValidation. You may use this property in case when you use widget without a model, since in this case widget is not able to detect client-side options automatically addButtonPosition integer|array : the position(s) of add button. This can be MultipleInput::POS_HEADER , MultipleInput::POS_ROW , MultipleInput::POS_ROW_BEGIN or MultipleInput::POS_FOOTER . addButtonOptions array : the HTML options for add button. Can contains class and label keys removeButtonOptions array : the HTML options for remove button. Can contains class and label keys data array : array of values in case you use widget without model models array : the list of models. Required in case you use TabularInput widget allowEmptyList boolean : whether to allow the empty list columnClass string : the name of column class. You can specify your own class to extend base functionality. Defaults to unclead\\multipleinput\\MultipleInputColumn for MultipleInput and unclead\\multipleinput\\TabularColumn for TabularInput . rendererClass string : the name of renderer class. You can specify your own class to extend base functionality. Defaults to unclead\\multipleinput\\renderers\\TableRenderer . columns array : the row columns configuration where you can set the properties which is described below rowOptions array|\\Closure : the HTML attributes for the table body rows. This can be either an array specifying the common HTML attributes for all body rows, or an anonymous function that returns an array of the HTML attributes. It should have the following signature: function ($model, $index, $context) $model : the current data model being rendered $index : the zero-based index of the data model in the model array $context : the widget object sortable bool : whether need to enable sorting or not modelClass string : a class of model which is used to render TabularInput . You must specify this property when a list of models is empty. If this property is not specified the widget will detect it based on a class of models cloneButton bool : whether need to enable clone buttons or not extraButtons string|\\Closure : the HTML content that will be rendered after the buttons. It can be either string or an anonymous function that returns a string which will be treated as HTML content. It should have the following signature: function ($model, $index, $context) $model : the current data model being rendered $index : the zero-based index of the data model in the model array $context : the MultipleInput widget object layoutConfig array : CSS grid classes for horizontal layout (only supported for ListRenderer class). This must be an array with these keys: 'offsetClass' : the offset grid class to append to the wrapper if no label is rendered 'labelClass' : the label grid class 'wrapperClass' : the wrapper grid class 'errorClass' : the error grid class showGeneralError bool : whether need to show error message for main attribute, when you don't want to validate particular input and want to validate a filed in general. Column options name string : input name. Required options type string : type of the input. If not set will default to textInput . Read more about the types described below title string : the column title value Closure : you can set it to an anonymous function with the following signature: function($data) {} defaultValue string : default value of input items array | Closure : the items for input with type dropDownList, listBox, checkboxList, radioList or anonymous function which return array of items and has the following signature: function($data) {} options array | Closure : the HTML attributes for the input, you can set it as array or an anonymous function with the following signature: function($data) {} headerOptions array : the HTML attributes for the header cell enableError boolean : whether to render inline error for the input. Default to false errorOptions array : the HTMl attributes for the error tag nameSuffix string : the unique prefix for attribute's name to avoid id duplication e.g. in case of using several copies of the widget on a page and one column is a Select2 widget tabindex integer : use it to customize a form element tabindex Input types Each column in a row can has their own type. Widget supports: all yii2 html input types: textInput dropDownList radioList textarea For more detail look at Html helper class input widget (widget that extends from InputWidget class). For example, yii\\widgets\\MaskedInput static to output a static HTML content For using widget as column input you may use the following code: echo $form->field($model, 'phones')->widget(MultipleInput::className(), [ ... 'columns' => [ ... [ 'name' => 'phones', 'title' => $model->getAttributeLabel('phones'), 'type' => \\yii\\widgets\\MaskedInput::className(), 'options' => [ 'class' => 'input-phone', 'mask' => '999-999-99-99', ], ], ], ])->label(false);","title":"Configuration"},{"location":"configuration/#configuration","text":"Widget support the following options that are additionally recognized over and above the configuration options in the InputWidget.","title":"Configuration"},{"location":"configuration/#base-options","text":"theme string : specify the theme of the widget. Available 2 themes: default with only widget css classes bs (twitter bootstrap) theme with additional BS ccs classes). Default value is bs max integer : maximum number of rows. If not set will default to unlimited min integer : minimum number of rows. Set to 0 if you need the empty list in case you don't have any data prepend boolean : add a new row to the beginning of the list, not to the end attributeOptions array : client-side attribute options, e.g. enableAjaxValidation. You may use this property in case when you use widget without a model, since in this case widget is not able to detect client-side options automatically addButtonPosition integer|array : the position(s) of add button. This can be MultipleInput::POS_HEADER , MultipleInput::POS_ROW , MultipleInput::POS_ROW_BEGIN or MultipleInput::POS_FOOTER . addButtonOptions array : the HTML options for add button. Can contains class and label keys removeButtonOptions array : the HTML options for remove button. Can contains class and label keys data array : array of values in case you use widget without model models array : the list of models. Required in case you use TabularInput widget allowEmptyList boolean : whether to allow the empty list columnClass string : the name of column class. You can specify your own class to extend base functionality. Defaults to unclead\\multipleinput\\MultipleInputColumn for MultipleInput and unclead\\multipleinput\\TabularColumn for TabularInput . rendererClass string : the name of renderer class. You can specify your own class to extend base functionality. Defaults to unclead\\multipleinput\\renderers\\TableRenderer . columns array : the row columns configuration where you can set the properties which is described below rowOptions array|\\Closure : the HTML attributes for the table body rows. This can be either an array specifying the common HTML attributes for all body rows, or an anonymous function that returns an array of the HTML attributes. It should have the following signature: function ($model, $index, $context) $model : the current data model being rendered $index : the zero-based index of the data model in the model array $context : the widget object sortable bool : whether need to enable sorting or not modelClass string : a class of model which is used to render TabularInput . You must specify this property when a list of models is empty. If this property is not specified the widget will detect it based on a class of models cloneButton bool : whether need to enable clone buttons or not extraButtons string|\\Closure : the HTML content that will be rendered after the buttons. It can be either string or an anonymous function that returns a string which will be treated as HTML content. It should have the following signature: function ($model, $index, $context) $model : the current data model being rendered $index : the zero-based index of the data model in the model array $context : the MultipleInput widget object layoutConfig array : CSS grid classes for horizontal layout (only supported for ListRenderer class). This must be an array with these keys: 'offsetClass' : the offset grid class to append to the wrapper if no label is rendered 'labelClass' : the label grid class 'wrapperClass' : the wrapper grid class 'errorClass' : the error grid class showGeneralError bool : whether need to show error message for main attribute, when you don't want to validate particular input and want to validate a filed in general.","title":"Base options"},{"location":"configuration/#column-options","text":"name string : input name. Required options type string : type of the input. If not set will default to textInput . Read more about the types described below title string : the column title value Closure : you can set it to an anonymous function with the following signature: function($data) {} defaultValue string : default value of input items array | Closure : the items for input with type dropDownList, listBox, checkboxList, radioList or anonymous function which return array of items and has the following signature: function($data) {} options array | Closure : the HTML attributes for the input, you can set it as array or an anonymous function with the following signature: function($data) {} headerOptions array : the HTML attributes for the header cell enableError boolean : whether to render inline error for the input. Default to false errorOptions array : the HTMl attributes for the error tag nameSuffix string : the unique prefix for attribute's name to avoid id duplication e.g. in case of using several copies of the widget on a page and one column is a Select2 widget tabindex integer : use it to customize a form element tabindex","title":"Column options"},{"location":"configuration/#input-types","text":"Each column in a row can has their own type. Widget supports: all yii2 html input types: textInput dropDownList radioList textarea For more detail look at Html helper class input widget (widget that extends from InputWidget class). For example, yii\\widgets\\MaskedInput static to output a static HTML content For using widget as column input you may use the following code: echo $form->field($model, 'phones')->widget(MultipleInput::className(), [ ... 'columns' => [ ... [ 'name' => 'phones', 'title' => $model->getAttributeLabel('phones'), 'type' => \\yii\\widgets\\MaskedInput::className(), 'options' => [ 'class' => 'input-phone', 'mask' => '999-999-99-99', ], ], ], ])->label(false);","title":"Input types"},{"location":"getting-started/","text":"Getting started I found this small guide here https://stackoverflow.com/a/51849747 and I think it is a good example of basic usage of the widget Question I want to generate a different number of rows with values from my database. How can I do this? I can design my columns in view and edit data manually after a page was generated. But miss how to program the number of rows and their values in the view. My code is as follows: <?= $form->field($User, 'User')->widget(MultipleInput::className(), [ 'min' => 0, 'max' => 4, 'columns' => [ [ 'name' => 'name', 'title' => 'Name', 'type' => 'textInput', 'options' => [ 'onchange' => $onchange, ], ], [ 'name' => 'birth', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Birth', 'value' => function($data) { return $data['day']; }, 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ] ], ] ])->label(false); How can I make (for example) 8 rows with different values, and also have the ability to edit/remove/update some of them? Answer You need to look into the documentation as it says that you need to assign a separate field into the model which will store all the schedule in form of JSON and then provide it back to the field when editing/updating the model. You have not added the appropriate model to verify how are you creating the field User in your given case above. so, I will try to create a simple example that will help you implement it in your scenario. For Example. You have to store a user in the database along with his favorite books. User id, name, email Books id, name Create a field/column in your User table with the name schedule of type text, you can write a migration or add manually. Add it to the rules in the User model as safe. like below public function rules() { return [ ....//other rules [ [ 'schedule'] , 'safe' ] ]; } Add the widget to the newly created column in ActiveForm echo $form->field($model,'schedule')->widget(MultipleInput::class,[ 'max' => 4, 'columns' => [ [ 'name' => 'book_id', 'type' => 'dropDownList', 'title' => 'Book', 'items' => ArrayHelper::map( Books::find()->asArray()->all (),'id','name'), ], ] ]); When saving the User model convert the array to JSON string if( Yii::$app->request->isPost && $model->load(Yii::$app->request->post()) ){ $model->schedule = \\yii\\helpers\\Json::encode($model->schedule); $model->save(); } Override the afterFind() of the User model to covert the JSON back to the array before loading the form public function afterFind() { parent::afterFind(); $this->schedule = \\yii\\helpers\\Json::decode($this->schedule); } Now when saved the schedule field against the current user will have the JSON for the selected rows for the books, as many selected, for example, if I saved three books having ids(1,2,3) then it will have JSON { \"0\": { \"book_id\": \"1\" }, \"2\": { \"book_id\": \"2\" }, \"3\": { \"book_id\": \"3\" } } The above JSON will be converted to an array in the afterFind() so that the widget loads the saved schedule when you EDIT the record. Now go to your update page or edit the newly saved model you will see the books loaded automatically.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"I found this small guide here https://stackoverflow.com/a/51849747 and I think it is a good example of basic usage of the widget","title":"Getting started"},{"location":"getting-started/#question","text":"I want to generate a different number of rows with values from my database. How can I do this? I can design my columns in view and edit data manually after a page was generated. But miss how to program the number of rows and their values in the view. My code is as follows: <?= $form->field($User, 'User')->widget(MultipleInput::className(), [ 'min' => 0, 'max' => 4, 'columns' => [ [ 'name' => 'name', 'title' => 'Name', 'type' => 'textInput', 'options' => [ 'onchange' => $onchange, ], ], [ 'name' => 'birth', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Birth', 'value' => function($data) { return $data['day']; }, 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ] ], ] ])->label(false); How can I make (for example) 8 rows with different values, and also have the ability to edit/remove/update some of them?","title":"Question"},{"location":"getting-started/#answer","text":"You need to look into the documentation as it says that you need to assign a separate field into the model which will store all the schedule in form of JSON and then provide it back to the field when editing/updating the model. You have not added the appropriate model to verify how are you creating the field User in your given case above. so, I will try to create a simple example that will help you implement it in your scenario. For Example. You have to store a user in the database along with his favorite books. User id, name, email Books id, name Create a field/column in your User table with the name schedule of type text, you can write a migration or add manually. Add it to the rules in the User model as safe. like below public function rules() { return [ ....//other rules [ [ 'schedule'] , 'safe' ] ]; } Add the widget to the newly created column in ActiveForm echo $form->field($model,'schedule')->widget(MultipleInput::class,[ 'max' => 4, 'columns' => [ [ 'name' => 'book_id', 'type' => 'dropDownList', 'title' => 'Book', 'items' => ArrayHelper::map( Books::find()->asArray()->all (),'id','name'), ], ] ]); When saving the User model convert the array to JSON string if( Yii::$app->request->isPost && $model->load(Yii::$app->request->post()) ){ $model->schedule = \\yii\\helpers\\Json::encode($model->schedule); $model->save(); } Override the afterFind() of the User model to covert the JSON back to the array before loading the form public function afterFind() { parent::afterFind(); $this->schedule = \\yii\\helpers\\Json::decode($this->schedule); } Now when saved the schedule field against the current user will have the JSON for the selected rows for the books, as many selected, for example, if I saved three books having ids(1,2,3) then it will have JSON { \"0\": { \"book_id\": \"1\" }, \"2\": { \"book_id\": \"2\" }, \"3\": { \"book_id\": \"3\" } } The above JSON will be converted to an array in the afterFind() so that the widget loads the saved schedule when you EDIT the record. Now go to your update page or edit the newly saved model you will see the books loaded automatically.","title":"Answer"},{"location":"icons/","text":"Using other icon libraries Multiple input and Tabular input widgets now support FontAwesome and indeed any other icon library you chose to integrate into your project. To take advantage of this, please proceed as follows: Include the preferred icon library in your project. If you wish to use font awesome , you can use the included FontAwesomeAsset which will integrate the free fa from their CDN; Add a mapping for your preferred icon library if it is not in the iconMap array of the widget, like the following; public $iconMap = [ 'glyphicons' => [ 'drag-handle' => 'glyphicon glyphicon-menu-hamburger', 'remove' => 'glyphicon glyphicon-remove', 'add' => 'glyphicon glyphicon-plus', 'clone' => 'glyphicon glyphicon-duplicate', ], 'fa' => [ 'drag-handle' => 'fa fa-bars', 'remove' => 'fa fa-times', 'add' => 'fa fa-plus', 'clone' => 'fa fa-files-o', ], 'my-amazing-icons' => [ 'drag-handle' => 'my my-bars', 'remove' => 'my my-times', 'add' => 'my my-plus', 'clone' => 'my my-files', ] ]; Set the preferred icon source public $iconSource = 'my-amazing-icons'; If you do none of the above, the default behavior which assumes you are using glyphicons is retained.","title":"Custom icons"},{"location":"icons/#using-other-icon-libraries","text":"Multiple input and Tabular input widgets now support FontAwesome and indeed any other icon library you chose to integrate into your project. To take advantage of this, please proceed as follows: Include the preferred icon library in your project. If you wish to use font awesome , you can use the included FontAwesomeAsset which will integrate the free fa from their CDN; Add a mapping for your preferred icon library if it is not in the iconMap array of the widget, like the following; public $iconMap = [ 'glyphicons' => [ 'drag-handle' => 'glyphicon glyphicon-menu-hamburger', 'remove' => 'glyphicon glyphicon-remove', 'add' => 'glyphicon glyphicon-plus', 'clone' => 'glyphicon glyphicon-duplicate', ], 'fa' => [ 'drag-handle' => 'fa fa-bars', 'remove' => 'fa fa-times', 'add' => 'fa fa-plus', 'clone' => 'fa fa-files-o', ], 'my-amazing-icons' => [ 'drag-handle' => 'my my-bars', 'remove' => 'my my-times', 'add' => 'my my-plus', 'clone' => 'my my-files', ] ]; Set the preferred icon source public $iconSource = 'my-amazing-icons'; If you do none of the above, the default behavior which assumes you are using glyphicons is retained.","title":"Using other icon libraries"},{"location":"installation/","text":"Installation The preferred way to install this extension is through composer . Either run php composer.phar require unclead/yii2-multiple-input \"~2.0\" or add \"unclead/yii2-multiple-input\": \"~2.0\" to the require section of your composer.json file.","title":"Installation"},{"location":"installation/#installation","text":"The preferred way to install this extension is through composer . Either run php composer.phar require unclead/yii2-multiple-input \"~2.0\" or add \"unclead/yii2-multiple-input\": \"~2.0\" to the require section of your composer.json file.","title":"Installation"},{"location":"javascript-events/","text":"Javascript events This widget has following events: afterInit : triggered after initialization afterAddRow : triggered after new row insertion beforeDeleteRow : triggered before the row removal afterDeleteRow : triggered after the row removal afterDropRow : triggered after drop the row when sortable mode is on Example jQuery('#multiple-input').on('afterInit', function(){ console.log('calls on after initialization event'); }).on('beforeAddRow', function(e, row, currentIndex) { console.log('calls on before add row event'); }).on('afterAddRow', function(e, row, currentIndex) { console.log('calls on after add row event'); }).on('beforeDeleteRow', function(e, row, currentIndex){ // row - HTML container of the current row for removal. // For TableRenderer it is tr.multiple-input-list__item console.log('calls on before remove row event.'); return confirm('Are you sure you want to delete row?') }).on('afterDeleteRow', function(e, row, currentIndex){ console.log('calls on after remove row event'); console.log(row); }).on('afterDropRow', function(e, item){ console.log('calls on after drop row', item); }); JavaScript operations add Adding new row with specified settings. Input arguments: object - values for inputs, can be filled with tags for dynamically added options for select (for ajax select). Example: $('#multiple-input').multipleInput('add', {first: 10, second: '<option value=\"2\" selected=\"selected\">second</option>'}); remove Remove row with specified index. Input arguments: integer - row number for removing, if not specified then removes last row. Example: $('#multiple-input').multipleInput('remove', 2); clear Remove all rows $('#multiple-input').multipleInput('clear'); option Get or set a particular option Input arguments: string - a name of an option mixed - a value of an option (optional). If specified will be used as a new value of an option; Example: $('#multiple-input').multipleInput('option', 'max'); $('#multiple-input').multipleInput('option', 'max', 10);","title":"JS events"},{"location":"javascript-events/#javascript-events","text":"This widget has following events: afterInit : triggered after initialization afterAddRow : triggered after new row insertion beforeDeleteRow : triggered before the row removal afterDeleteRow : triggered after the row removal afterDropRow : triggered after drop the row when sortable mode is on Example jQuery('#multiple-input').on('afterInit', function(){ console.log('calls on after initialization event'); }).on('beforeAddRow', function(e, row, currentIndex) { console.log('calls on before add row event'); }).on('afterAddRow', function(e, row, currentIndex) { console.log('calls on after add row event'); }).on('beforeDeleteRow', function(e, row, currentIndex){ // row - HTML container of the current row for removal. // For TableRenderer it is tr.multiple-input-list__item console.log('calls on before remove row event.'); return confirm('Are you sure you want to delete row?') }).on('afterDeleteRow', function(e, row, currentIndex){ console.log('calls on after remove row event'); console.log(row); }).on('afterDropRow', function(e, item){ console.log('calls on after drop row', item); });","title":"Javascript events"},{"location":"javascript-events/#javascript-operations","text":"","title":"JavaScript operations"},{"location":"javascript-events/#add","text":"Adding new row with specified settings. Input arguments: object - values for inputs, can be filled with tags for dynamically added options for select (for ajax select). Example: $('#multiple-input').multipleInput('add', {first: 10, second: '<option value=\"2\" selected=\"selected\">second</option>'});","title":"add"},{"location":"javascript-events/#remove","text":"Remove row with specified index. Input arguments: integer - row number for removing, if not specified then removes last row. Example: $('#multiple-input').multipleInput('remove', 2);","title":"remove"},{"location":"javascript-events/#clear","text":"Remove all rows $('#multiple-input').multipleInput('clear');","title":"clear"},{"location":"javascript-events/#option","text":"Get or set a particular option Input arguments: string - a name of an option mixed - a value of an option (optional). If specified will be used as a new value of an option; Example: $('#multiple-input').multipleInput('option', 'max'); $('#multiple-input').multipleInput('option', 'max', 10);","title":"option"},{"location":"renderers/","text":"Renderers Currently widget supports three type of renderers TableRenderer This renderer is enabled by default. ListRenderer To enable this renderer you have to use an option rendererClass <?php echo $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'rendererClass' => \\unclead\\multipleinput\\renderers\\ListRenderer::className(), 'max' => 4, 'allowEmptyList' => true, 'rowOptions' => function($model) { $options = []; if ($model['priority'] > 1) { $options['class'] = 'danger'; } return $options; }, DivRenderer To enable this renderer you have to use an option rendererClass <?php echo $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'rendererClass' => \\unclead\\multipleinput\\renderers\\ListRenderer::class, 'addButtonPosition' => MultipleInput::POS_ROW, // show add button inside of the row 'extraButtons' => function ($model, $index, $context) { if ($index === 0) { return Html::tag('div', Yii::t('object', 'Add object'), ['class' => 'mi-after-add']); } return Html::tag('div', Yii::t('object', 'Remove object'), ['class' => 'mi-after-remove']); }, 'layoutConfig' => [ 'offsetClass' => 'col-md-offset-2', 'labelClass' => 'col-md-2', 'wrapperClass' => 'col-md-6', 'errorClass' => 'col-md-offset-2 col-md-6', 'buttonActionClass' => 'col-md-offset-1 col-md-2', ], ...","title":"Renderers"},{"location":"renderers/#renderers","text":"Currently widget supports three type of renderers","title":"Renderers"},{"location":"renderers/#tablerenderer","text":"This renderer is enabled by default.","title":"TableRenderer"},{"location":"renderers/#listrenderer","text":"To enable this renderer you have to use an option rendererClass <?php echo $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'rendererClass' => \\unclead\\multipleinput\\renderers\\ListRenderer::className(), 'max' => 4, 'allowEmptyList' => true, 'rowOptions' => function($model) { $options = []; if ($model['priority'] > 1) { $options['class'] = 'danger'; } return $options; },","title":"ListRenderer"},{"location":"renderers/#divrenderer","text":"To enable this renderer you have to use an option rendererClass <?php echo $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'rendererClass' => \\unclead\\multipleinput\\renderers\\ListRenderer::class, 'addButtonPosition' => MultipleInput::POS_ROW, // show add button inside of the row 'extraButtons' => function ($model, $index, $context) { if ($index === 0) { return Html::tag('div', Yii::t('object', 'Add object'), ['class' => 'mi-after-add']); } return Html::tag('div', Yii::t('object', 'Remove object'), ['class' => 'mi-after-remove']); }, 'layoutConfig' => [ 'offsetClass' => 'col-md-offset-2', 'labelClass' => 'col-md-2', 'wrapperClass' => 'col-md-6', 'errorClass' => 'col-md-offset-2 col-md-6', 'buttonActionClass' => 'col-md-offset-1 col-md-2', ], ...","title":"DivRenderer"},{"location":"tips-and-tricks/","text":"Tips and tricks How to customize buttons You can customize add and remove buttons via addButtonOptions and removeButtonOptions . Here is a simple example of how you can use those options: echo $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 5, 'addButtonOptions' => [ 'class' => 'btn btn-success', 'label' => 'add' // also you can use html code ], 'removeButtonOptions' => [ 'label' => 'remove' ] ]) ->label(false); How to add content after the buttons You can add html content after add and remove buttons via extraButtons . echo $form->field($model, 'field')->widget(MultipleInput::className(), [ 'rendererClass' => \\unclead\\multipleinput\\renderers\\ListRenderer::class, 'extraButtons' => function ($model, $index, $context) { return Html::tag('span', '', ['class' => \"btn-show-hide-{$index} glyphicon glyphicon-eye-open btn btn-info\"]); }, ]) ->label(false); Work with an empty list In some cases, you need to have the ability to delete all rows in the list. For this purpose, you can use option allowEmptyList like in the example below: echo $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 5, 'allowEmptyList' => true ]) ->label(false); Also, you can set 0 in min option if you don't need the first blank row when data is empty. Guess column title Sometimes you can use the widget without defining columns but you want to have the column header of the table. In this case, you can use the option enableGuessTitle like in the example below: echo $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 5, 'allowEmptyList' => true, 'enableGuessTitle' => true ]) ->label(false); Ajax loading of a widget Assume you want to load a widget via ajax and then show it inside the modal window. In this case, you MUST: Ensure that you specified the ID of the widget otherwise the widget will get a random ID and it can be the same as the ID of others elements on the page. Ensure that you use the widget inside ActiveForm because it works incorrectly in this case. Use of a widget's placeholder You can use a placeholder {multiple_index} in a widget configuration, e.g. for implementation of dependent drop-down lists. <?= $form->field($model, 'field')->widget(MultipleInput::className(), [ 'id' => 'my_id', 'allowEmptyList' => false, 'rowOptions' => [ 'id' => 'row{multiple_index_my_id}', ], 'columns' => [ [ 'name' => 'category', 'type' => 'dropDownList', 'title' => 'Category', 'defaultValue' => '1', 'items' => [ '1' => 'Test 1', '2' => 'Test 2', '3' => 'Test 3', '4' => 'Test 4', ], 'options' => [ 'onchange' => <<< JS $.post(\"list?id=\" + $(this).val(), function(data){ console.log(data); $(\"select#subcat-{multiple_index_my_id}\").html(data); }); JS ], ], [ 'name' => 'subcategory', 'type' => 'dropDownList', 'title' => 'Subcategory', 'items' => [], 'options'=> [ 'id' => 'subcat-{multiple_index_my_id}' ], ], ] ]); ?> Important Ensure that you added ID of widget to a base placeholder multiple_index Custom index of the row Assume that you want to set a specific index for each row. In this case, you can pass the data attribute as an associative array as in the example below: <?= $form->field($model, 'field')->widget(MultipleInput::className(), [ 'allowEmptyList' => false, 'data' => [ 3 => [ 'day' => '27.02.2015', 'user_id' => 31, 'priority' => 1, 'enable' => 1 ], 'some-key' => [ 'day' => '27.02.2015', 'user_id' => 33, 'priority' => 2, 'enable' => 0 ], ] ... Embedded MultipleInput widget You can use nested MultipleInput as in the example below: echo MultipleInput::widget([ 'model' => $model, 'attribute' => 'questions', 'attributeOptions' => $commonAttributeOptions, 'columns' => [ [ 'name' => 'question', 'type' => 'textarea', ], [ 'name' => 'answers', 'type' => MultipleInput::class, 'options' => [ 'attributeOptions' => $commonAttributeOptions, 'columns' => [ [ 'name' => 'right', 'type' => MultipleInputColumn::TYPE_CHECKBOX ], [ 'name' => 'answer' ] ] ] ] ], ]); But in this case, you have to pass attributeOptions to the widget otherwise, you will not be able to use ajax or client-side validation of data. Client validation Apart from ajax validation, you can use client validation but in this case, you MUST set property form . Also, ensure that you set enableClientValidation to true value in property attributeOptions . If you want to use client validation for a particular column you can use the property attributeOptions . An example of using client validation is listed below: <?= TabularInput::widget([ 'models' => $models, 'form' => $form, 'attributeOptions' => [ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ], 'columns' => [ [ 'name' => 'id', 'type' => TabularColumn::TYPE_HIDDEN_INPUT ], [ 'name' => 'title', 'title' => 'Title', 'type' => TabularColumn::TYPE_TEXT_INPUT, 'attributeOptions' => [ 'enableClientValidation' => true, 'validateOnChange' => true, ], 'enableError' => true ], [ 'name' => 'description', 'title' => 'Description', ], ], ]) ?> In the example above we use client validation for column title and ajax validation for column description . As you can seee we also enabled validateOnChange for column title thus you can use all client-side options from the ActiveField class.","title":"Tips and Tricks"},{"location":"tips-and-tricks/#tips-and-tricks","text":"","title":"Tips and tricks"},{"location":"tips-and-tricks/#how-to-customize-buttons","text":"You can customize add and remove buttons via addButtonOptions and removeButtonOptions . Here is a simple example of how you can use those options: echo $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 5, 'addButtonOptions' => [ 'class' => 'btn btn-success', 'label' => 'add' // also you can use html code ], 'removeButtonOptions' => [ 'label' => 'remove' ] ]) ->label(false);","title":"How to customize buttons"},{"location":"tips-and-tricks/#how-to-add-content-after-the-buttons","text":"You can add html content after add and remove buttons via extraButtons . echo $form->field($model, 'field')->widget(MultipleInput::className(), [ 'rendererClass' => \\unclead\\multipleinput\\renderers\\ListRenderer::class, 'extraButtons' => function ($model, $index, $context) { return Html::tag('span', '', ['class' => \"btn-show-hide-{$index} glyphicon glyphicon-eye-open btn btn-info\"]); }, ]) ->label(false);","title":"How to add content after the buttons"},{"location":"tips-and-tricks/#work-with-an-empty-list","text":"In some cases, you need to have the ability to delete all rows in the list. For this purpose, you can use option allowEmptyList like in the example below: echo $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 5, 'allowEmptyList' => true ]) ->label(false); Also, you can set 0 in min option if you don't need the first blank row when data is empty.","title":"Work with an empty list"},{"location":"tips-and-tricks/#guess-column-title","text":"Sometimes you can use the widget without defining columns but you want to have the column header of the table. In this case, you can use the option enableGuessTitle like in the example below: echo $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 5, 'allowEmptyList' => true, 'enableGuessTitle' => true ]) ->label(false);","title":"Guess column title"},{"location":"tips-and-tricks/#ajax-loading-of-a-widget","text":"Assume you want to load a widget via ajax and then show it inside the modal window. In this case, you MUST: Ensure that you specified the ID of the widget otherwise the widget will get a random ID and it can be the same as the ID of others elements on the page. Ensure that you use the widget inside ActiveForm because it works incorrectly in this case.","title":"Ajax loading of a widget"},{"location":"tips-and-tricks/#use-of-a-widgets-placeholder","text":"You can use a placeholder {multiple_index} in a widget configuration, e.g. for implementation of dependent drop-down lists. <?= $form->field($model, 'field')->widget(MultipleInput::className(), [ 'id' => 'my_id', 'allowEmptyList' => false, 'rowOptions' => [ 'id' => 'row{multiple_index_my_id}', ], 'columns' => [ [ 'name' => 'category', 'type' => 'dropDownList', 'title' => 'Category', 'defaultValue' => '1', 'items' => [ '1' => 'Test 1', '2' => 'Test 2', '3' => 'Test 3', '4' => 'Test 4', ], 'options' => [ 'onchange' => <<< JS $.post(\"list?id=\" + $(this).val(), function(data){ console.log(data); $(\"select#subcat-{multiple_index_my_id}\").html(data); }); JS ], ], [ 'name' => 'subcategory', 'type' => 'dropDownList', 'title' => 'Subcategory', 'items' => [], 'options'=> [ 'id' => 'subcat-{multiple_index_my_id}' ], ], ] ]); ?> Important Ensure that you added ID of widget to a base placeholder multiple_index","title":"Use of a widget's placeholder"},{"location":"tips-and-tricks/#custom-index-of-the-row","text":"Assume that you want to set a specific index for each row. In this case, you can pass the data attribute as an associative array as in the example below: <?= $form->field($model, 'field')->widget(MultipleInput::className(), [ 'allowEmptyList' => false, 'data' => [ 3 => [ 'day' => '27.02.2015', 'user_id' => 31, 'priority' => 1, 'enable' => 1 ], 'some-key' => [ 'day' => '27.02.2015', 'user_id' => 33, 'priority' => 2, 'enable' => 0 ], ] ...","title":"Custom index of the row"},{"location":"tips-and-tricks/#embedded-multipleinput-widget","text":"You can use nested MultipleInput as in the example below: echo MultipleInput::widget([ 'model' => $model, 'attribute' => 'questions', 'attributeOptions' => $commonAttributeOptions, 'columns' => [ [ 'name' => 'question', 'type' => 'textarea', ], [ 'name' => 'answers', 'type' => MultipleInput::class, 'options' => [ 'attributeOptions' => $commonAttributeOptions, 'columns' => [ [ 'name' => 'right', 'type' => MultipleInputColumn::TYPE_CHECKBOX ], [ 'name' => 'answer' ] ] ] ] ], ]); But in this case, you have to pass attributeOptions to the widget otherwise, you will not be able to use ajax or client-side validation of data.","title":"Embedded MultipleInput widget"},{"location":"tips-and-tricks/#client-validation","text":"Apart from ajax validation, you can use client validation but in this case, you MUST set property form . Also, ensure that you set enableClientValidation to true value in property attributeOptions . If you want to use client validation for a particular column you can use the property attributeOptions . An example of using client validation is listed below: <?= TabularInput::widget([ 'models' => $models, 'form' => $form, 'attributeOptions' => [ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ], 'columns' => [ [ 'name' => 'id', 'type' => TabularColumn::TYPE_HIDDEN_INPUT ], [ 'name' => 'title', 'title' => 'Title', 'type' => TabularColumn::TYPE_TEXT_INPUT, 'attributeOptions' => [ 'enableClientValidation' => true, 'validateOnChange' => true, ], 'enableError' => true ], [ 'name' => 'description', 'title' => 'Description', ], ], ]) ?> In the example above we use client validation for column title and ajax validation for column description . As you can seee we also enabled validateOnChange for column title thus you can use all client-side options from the ActiveField class.","title":"Client validation"},{"location":"usage/","text":"Usage You can find the source code of examples here One column For example, your application contains the model User that has the related model UserEmail You can add virtual attribute emails for collect emails from a form and then you can save them to the database. In this case, you can use yii2-multiple-input widget for supporting multiple inputs how to describe below. First of all, we have to declare a virtual attribute in the model class ExampleModel extends Model { /** * @var array virtual attribute for keeping emails */ public $emails; Then we have to use MultipleInput widget for rendering form field in the view file use yii\\bootstrap\\ActiveForm; use unclead\\multipleinput\\MultipleInput; use unclead\\multipleinput\\examples\\models\\ExampleModel; use yii\\helpers\\Html; /* @var $this \\yii\\base\\View */ /* @var $model ExampleModel */ ?> <?php $form = ActiveForm::begin([ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ]);?> <?= $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 4, ]); ?> <?= Html::submitButton('Update', ['class' => 'btn btn-success']);?> <?php ActiveForm::end();?> Options max means that a user is able to input only 4 emails For validation emails, you can use the following code /** * Email validation. * * @param $attribute */ public function validateEmails($attribute) { $items = $this->$attribute; if (!is_array($items)) { $items = []; } foreach ($items as $index => $item) { $validator = new EmailValidator(); $error = null; $validator->validate($item, $error); if (!empty($error)) { $key = $attribute . '[' . $index . ']'; $this->addError($key, $error); } } } Multiple columns For example, you want to have an interface for manage a user schedule. For simplicity, we will store the schedule in json string. In this case, you can use yii2-multiple-input widget for supporting multiple inputs how to describe below. Our test model can look like as the following snippet class ExampleModel extends Model { public $schedule; public function init() { parent::init(); $this->schedule = [ [ 'day' => '27.02.2015', 'user_id' => 1, 'priority' => 1 ], [ 'day' => '27.02.2015', 'user_id' => 2, 'priority' => 2 ], ]; } Then we have to use MultipleInput widget for rendering form field in the view file use yii\\bootstrap\\ActiveForm; use unclead\\multipleinput\\MultipleInput; use unclead\\multipleinput\\examples\\models\\ExampleModel; use yii\\helpers\\Html; /* @var $this \\yii\\base\\View */ /* @var $model ExampleModel */ ?> <?php $form = ActiveForm::begin([ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ]);?> <?= $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'max' => 4, 'columns' => [ [ 'name' => 'user_id', 'type' => 'dropDownList', 'title' => 'User', 'defaultValue' => 1, 'items' => [ 1 => 'User 1', 2 => 'User 2' ] ], [ 'name' => 'day', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Day', 'value' => function($data) { return $data['day']; }, 'items' => [ '0' => 'Saturday', '1' => 'Monday' ], 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ] ], [ 'name' => 'priority', 'title' => 'Priority', 'enableError' => true, 'options' => [ 'class' => 'input-priority' ] ] ] ]); ?> <?= Html::submitButton('Update', ['class' => 'btn btn-success']);?> <?php ActiveForm::end();?> For validation of the schedule you can use the following code public function validateSchedule($attribute) { $requiredValidator = new RequiredValidator(); foreach($this->$attribute as $index => $row) { $error = null; $requiredValidator->validate($row['priority'], $error); if (!empty($error)) { $key = $attribute . '[' . $index . '][priority]'; $this->addError($key, $error); } } } For example, you keep some data in json format in an attribute of a model. Imagine that it is an abstract user schedule with keys: user_id, day, priority On the edit page, you want to be able to manage this schedule and you can you yii2-multiple-input widget like in the following code use unclead\\multipleinput\\MultipleInput; ... <?= $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'max' => 4, 'columns' => [ [ 'name' => 'user_id', 'type' => 'dropDownList', 'title' => 'User', 'defaultValue' => 1, 'items' => [ 1 => 'User 1', 2 => 'User 2' ] ], [ 'name' => 'day', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Day', 'value' => function($data) { return $data['day']; }, 'items' => [ '0' => 'Saturday', '1' => 'Monday' ], 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ], 'headerOptions' => [ 'style' => 'width: 250px;', 'class' => 'day-css-class' ] ], [ 'name' => 'priority', 'enableError' => true, 'title' => 'Priority', 'options' => [ 'class' => 'input-priority' ] ], [ 'name' => 'comment', 'type' => 'static', 'value' => function($data) { return Html::tag('span', 'static content', ['class' => 'label label-info']); }, 'headerOptions' => [ 'style' => 'width: 70px;', ] ] ] ]); ?> Tabular input For example, you want to have an interface for manage some abstract items via tabular input. In this case, you can use yii2-multiple-input widget for supporting tabular input how to describe below. Our test model can look like as the following snippet namespace unclead\\multipleinput\\examples\\models; use Yii; use yii\\base\\Model; // you have to install https://github.com/vova07/yii2-fileapi-widget use vova07\\fileapi\\behaviors\\UploadBehavior; /** * Class Item * @package unclead\\multipleinput\\examples\\models */ class Item extends Model { public $title; public $description; public $file; public $date; public function behaviors() { return [ 'uploadBehavior' => [ 'class' => UploadBehavior::className(), 'attributes' => [ 'file' => [ 'path' => Yii::getAlias('@webroot') . '/images/', 'tempPath' => Yii::getAlias('@webroot') . '/images/tmp/', 'url' => '/images/' ], ] ] ]; } public function rules() { return [ [['title', 'description'], 'required'], ['file', 'safe'] ]; } } Then we have to use TabularInput widget for rendering form field in the view file Since version 2.18.0 you can configure columnOptions also. <?php use yii\\bootstrap\\ActiveForm; use unclead\\multipleinput\\TabularInput; use yii\\helpers\\Html; use \\unclead\\multipleinput\\examples\\models\\Item; /* @var $this \\yii\\web\\View */ /* @var $models Item[] */ ?> <?php $form = \\yii\\bootstrap\\ActiveForm::begin([ 'id' => 'tabular-form', 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, 'options' => [ 'enctype' => 'multipart/form-data' ] ]) ?> <?= TabularInput::widget([ 'models' => $models, 'attributeOptions' => [ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ], 'columns' => [ [ 'name' => 'title', 'title' => 'Title', 'type' => \\unclead\\multipleinput\\MultipleInputColumn::TYPE_TEXT_INPUT, ], [ 'name' => 'description', 'title' => 'Description', ], [ 'name' => 'file', 'title' => 'File', 'type' => \\vova07\\fileapi\\Widget::className(), 'options' => [ 'settings' => [ 'url' => ['site/fileapi-upload'] ] ], 'columnOptions' => [ 'style' => 'width: 250px;', 'class' => 'custom-css-class' ] ], [ 'name' => 'date', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Day', 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ], 'headerOptions' => [ 'style' => 'width: 250px;', 'class' => 'day-css-class' ] ], ], ]) ?> <?= Html::submitButton('Update', ['class' => 'btn btn-success']);?> <?php ActiveForm::end();?> Your action can look like the following code /** * Class TabularInputAction * @package unclead\\multipleinput\\examples\\actions */ class TabularInputAction extends Action { public function run() { Yii::setAlias('@unclead-examples', realpath(__DIR__ . '/../')); $models = [new Item()]; $request = Yii::$app->getRequest(); if ($request->isPost && $request->post('ajax') !== null) { $data = Yii::$app->request->post('Item', []); foreach (array_keys($data) as $index) { $models[$index] = new Item(); } Model::loadMultiple($models, Yii::$app->request->post()); Yii::$app->response->format = Response::FORMAT_JSON; $result = ActiveForm::validateMultiple($models); return $result; } if (Model::loadMultiple($models, Yii::$app->request->post())) { // your magic } return $this->controller->render('@unclead-examples/views/tabular-input.php', ['models' => $models]); } }","title":"Usage"},{"location":"usage/#usage","text":"You can find the source code of examples here","title":"Usage"},{"location":"usage/#one-column","text":"For example, your application contains the model User that has the related model UserEmail You can add virtual attribute emails for collect emails from a form and then you can save them to the database. In this case, you can use yii2-multiple-input widget for supporting multiple inputs how to describe below. First of all, we have to declare a virtual attribute in the model class ExampleModel extends Model { /** * @var array virtual attribute for keeping emails */ public $emails; Then we have to use MultipleInput widget for rendering form field in the view file use yii\\bootstrap\\ActiveForm; use unclead\\multipleinput\\MultipleInput; use unclead\\multipleinput\\examples\\models\\ExampleModel; use yii\\helpers\\Html; /* @var $this \\yii\\base\\View */ /* @var $model ExampleModel */ ?> <?php $form = ActiveForm::begin([ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ]);?> <?= $form->field($model, 'emails')->widget(MultipleInput::className(), [ 'max' => 4, ]); ?> <?= Html::submitButton('Update', ['class' => 'btn btn-success']);?> <?php ActiveForm::end();?> Options max means that a user is able to input only 4 emails For validation emails, you can use the following code /** * Email validation. * * @param $attribute */ public function validateEmails($attribute) { $items = $this->$attribute; if (!is_array($items)) { $items = []; } foreach ($items as $index => $item) { $validator = new EmailValidator(); $error = null; $validator->validate($item, $error); if (!empty($error)) { $key = $attribute . '[' . $index . ']'; $this->addError($key, $error); } } }","title":"One column"},{"location":"usage/#multiple-columns","text":"For example, you want to have an interface for manage a user schedule. For simplicity, we will store the schedule in json string. In this case, you can use yii2-multiple-input widget for supporting multiple inputs how to describe below. Our test model can look like as the following snippet class ExampleModel extends Model { public $schedule; public function init() { parent::init(); $this->schedule = [ [ 'day' => '27.02.2015', 'user_id' => 1, 'priority' => 1 ], [ 'day' => '27.02.2015', 'user_id' => 2, 'priority' => 2 ], ]; } Then we have to use MultipleInput widget for rendering form field in the view file use yii\\bootstrap\\ActiveForm; use unclead\\multipleinput\\MultipleInput; use unclead\\multipleinput\\examples\\models\\ExampleModel; use yii\\helpers\\Html; /* @var $this \\yii\\base\\View */ /* @var $model ExampleModel */ ?> <?php $form = ActiveForm::begin([ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ]);?> <?= $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'max' => 4, 'columns' => [ [ 'name' => 'user_id', 'type' => 'dropDownList', 'title' => 'User', 'defaultValue' => 1, 'items' => [ 1 => 'User 1', 2 => 'User 2' ] ], [ 'name' => 'day', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Day', 'value' => function($data) { return $data['day']; }, 'items' => [ '0' => 'Saturday', '1' => 'Monday' ], 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ] ], [ 'name' => 'priority', 'title' => 'Priority', 'enableError' => true, 'options' => [ 'class' => 'input-priority' ] ] ] ]); ?> <?= Html::submitButton('Update', ['class' => 'btn btn-success']);?> <?php ActiveForm::end();?> For validation of the schedule you can use the following code public function validateSchedule($attribute) { $requiredValidator = new RequiredValidator(); foreach($this->$attribute as $index => $row) { $error = null; $requiredValidator->validate($row['priority'], $error); if (!empty($error)) { $key = $attribute . '[' . $index . '][priority]'; $this->addError($key, $error); } } } For example, you keep some data in json format in an attribute of a model. Imagine that it is an abstract user schedule with keys: user_id, day, priority On the edit page, you want to be able to manage this schedule and you can you yii2-multiple-input widget like in the following code use unclead\\multipleinput\\MultipleInput; ... <?= $form->field($model, 'schedule')->widget(MultipleInput::className(), [ 'max' => 4, 'columns' => [ [ 'name' => 'user_id', 'type' => 'dropDownList', 'title' => 'User', 'defaultValue' => 1, 'items' => [ 1 => 'User 1', 2 => 'User 2' ] ], [ 'name' => 'day', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Day', 'value' => function($data) { return $data['day']; }, 'items' => [ '0' => 'Saturday', '1' => 'Monday' ], 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ], 'headerOptions' => [ 'style' => 'width: 250px;', 'class' => 'day-css-class' ] ], [ 'name' => 'priority', 'enableError' => true, 'title' => 'Priority', 'options' => [ 'class' => 'input-priority' ] ], [ 'name' => 'comment', 'type' => 'static', 'value' => function($data) { return Html::tag('span', 'static content', ['class' => 'label label-info']); }, 'headerOptions' => [ 'style' => 'width: 70px;', ] ] ] ]); ?>","title":"Multiple columns"},{"location":"usage/#tabular-input","text":"For example, you want to have an interface for manage some abstract items via tabular input. In this case, you can use yii2-multiple-input widget for supporting tabular input how to describe below. Our test model can look like as the following snippet namespace unclead\\multipleinput\\examples\\models; use Yii; use yii\\base\\Model; // you have to install https://github.com/vova07/yii2-fileapi-widget use vova07\\fileapi\\behaviors\\UploadBehavior; /** * Class Item * @package unclead\\multipleinput\\examples\\models */ class Item extends Model { public $title; public $description; public $file; public $date; public function behaviors() { return [ 'uploadBehavior' => [ 'class' => UploadBehavior::className(), 'attributes' => [ 'file' => [ 'path' => Yii::getAlias('@webroot') . '/images/', 'tempPath' => Yii::getAlias('@webroot') . '/images/tmp/', 'url' => '/images/' ], ] ] ]; } public function rules() { return [ [['title', 'description'], 'required'], ['file', 'safe'] ]; } } Then we have to use TabularInput widget for rendering form field in the view file Since version 2.18.0 you can configure columnOptions also. <?php use yii\\bootstrap\\ActiveForm; use unclead\\multipleinput\\TabularInput; use yii\\helpers\\Html; use \\unclead\\multipleinput\\examples\\models\\Item; /* @var $this \\yii\\web\\View */ /* @var $models Item[] */ ?> <?php $form = \\yii\\bootstrap\\ActiveForm::begin([ 'id' => 'tabular-form', 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, 'options' => [ 'enctype' => 'multipart/form-data' ] ]) ?> <?= TabularInput::widget([ 'models' => $models, 'attributeOptions' => [ 'enableAjaxValidation' => true, 'enableClientValidation' => false, 'validateOnChange' => false, 'validateOnSubmit' => true, 'validateOnBlur' => false, ], 'columns' => [ [ 'name' => 'title', 'title' => 'Title', 'type' => \\unclead\\multipleinput\\MultipleInputColumn::TYPE_TEXT_INPUT, ], [ 'name' => 'description', 'title' => 'Description', ], [ 'name' => 'file', 'title' => 'File', 'type' => \\vova07\\fileapi\\Widget::className(), 'options' => [ 'settings' => [ 'url' => ['site/fileapi-upload'] ] ], 'columnOptions' => [ 'style' => 'width: 250px;', 'class' => 'custom-css-class' ] ], [ 'name' => 'date', 'type' => \\kartik\\date\\DatePicker::className(), 'title' => 'Day', 'options' => [ 'pluginOptions' => [ 'format' => 'dd.mm.yyyy', 'todayHighlight' => true ] ], 'headerOptions' => [ 'style' => 'width: 250px;', 'class' => 'day-css-class' ] ], ], ]) ?> <?= Html::submitButton('Update', ['class' => 'btn btn-success']);?> <?php ActiveForm::end();?> Your action can look like the following code /** * Class TabularInputAction * @package unclead\\multipleinput\\examples\\actions */ class TabularInputAction extends Action { public function run() { Yii::setAlias('@unclead-examples', realpath(__DIR__ . '/../')); $models = [new Item()]; $request = Yii::$app->getRequest(); if ($request->isPost && $request->post('ajax') !== null) { $data = Yii::$app->request->post('Item', []); foreach (array_keys($data) as $index) { $models[$index] = new Item(); } Model::loadMultiple($models, Yii::$app->request->post()); Yii::$app->response->format = Response::FORMAT_JSON; $result = ActiveForm::validateMultiple($models); return $result; } if (Model::loadMultiple($models, Yii::$app->request->post())) { // your magic } return $this->controller->render('@unclead-examples/views/tabular-input.php', ['models' => $models]); } }","title":"Tabular input"}]}